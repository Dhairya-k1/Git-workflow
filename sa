[1mdiff --git a/README.markdown b/README.markdown[m
[1mdeleted file mode 100644[m
[1mindex 9e81c5f..0000000[m
[1m--- a/README.markdown[m
[1m+++ /dev/null[m
[36m@@ -1,53 +0,0 @@[m
[31m-# AI Git Workflow Management Project[m
[31m-[m
[31m-This project uses AI to enhance Git workflow management by automating pull request reviews and generating commit messages.[m
[31m-[m
[31m-## Features[m
[31m-- **Automated PR Review**: Analyzes code changes in a branch and provides feedback using AI.[m
[31m-- **AI-Generated Commit Messages**: Generates meaningful commit messages based on staged changes.[m
[31m-[m
[31m-## Prerequisites[m
[31m-- Python 3.8 or higher[m
[31m-- A Git repository[m
[31m-- Dependencies: `gitpython`, `transformers`, `torch`[m
[31m-[m
[31m-## Setup[m
[31m-1. Clone this repository:[m
[31m-   ```bash[m
[31m-   git clone <your-repo-url>[m
[31m-   cd ai-git-workflow[m
[31m-   ```[m
[31m-2. Create a virtual environment and activate it:[m
[31m-   ```bash[m
[31m-   python -m venv venv[m
[31m-   source venv/bin/activate  # On Windows: venv\Scripts\activate[m
[31m-   ```[m
[31m-3. Install dependencies:[m
[31m-   ```bash[m
[31m-   pip install gitpython transformers torch[m
[31m-   ```[m
[31m-4. Ensure you're in a Git repository with a `main` branch.[m
[31m-[m
[31m-## Usage[m
[31m-Run the tool with one of the following commands:[m
[31m-[m
[31m-### Automated PR Review[m
[31m-Review changes in a branch compared to `main`:[m
[31m-```bash[m
[31m-python main.py pr_review <branch_name>[m
[31m-```[m
[31m-[m
[31m-### Generate Commit Message[m
[31m-Generate a commit message for staged changes:[m
[31m-```bash[m
[31m-python main.py commit_message[m
[31m-```[m
[31m-[m
[31m-## Limitations[m
[31m-- The AI model (`distilbert-base-uncased`) is basic and used for demonstration. For better results, fine-tune a model on code-specific datasets.[m
[31m-- PR reviews are simplistic (using sentiment analysis as a proxy). A production system would need a model trained for code quality analysis.[m
[31m-[m
[31m-## Future Improvements[m
[31m-- Fine-tune an AI model for code-specific tasks.[m
[31m-- Add support for more Git workflow features (e.g., conflict resolution).[m
[31m-- Integrate with Git hosting platforms like GitHub for direct PR comments.[m
\ No newline at end of file[m
[1mdiff --git a/__pycache__/git_suggestion.cpython-313.pyc b/__pycache__/git_suggestion.cpython-313.pyc[m
[1mindex 344b831..8bb0e3d 100644[m
Binary files a/__pycache__/git_suggestion.cpython-313.pyc and b/__pycache__/git_suggestion.cpython-313.pyc differ
[1mdiff --git a/commit_message.py b/commit_message.py[m
[1mdeleted file mode 100644[m
[1mindex e51c292..0000000[m
[1m--- a/commit_message.py[m
[1m+++ /dev/null[m
[36m@@ -1,24 +0,0 @@[m
[31m-from transformers import pipeline[m
[31m-[m
[31m-def generate_commit_message(diff):[m
[31m-    try:[m
[31m-        # Initialize AI model for text generation[m
[31m-        generator = pipeline("text-generation", model="distilbert-base-uncased")[m
[31m-[m
[31m-        # Create a prompt based on the diff[m
[31m-        prompt = f"Generate a concise Git commit message for the following changes:\n{diff[:512]}\nCommit message:"[m
[31m-[m
[31m-        # Generate the commit message[m
[31m-        result = generator(prompt, max_length=100, num_return_sequences=1, truncation=True)[0][m
[31m-        message = result["generated_text"].split("Commit message:")[-1].strip()[m
[31m-[m
[31m-        # Clean up the message[m
[31m-        message = message.split("\n")[0]  # Take the first line[m
[31m-        if len(message) > 72:  # Git commit message length guideline[m
[31m-            message = message[:69] + "..."[m
[31m-[m
[31m-        return message[m
[31m-[m
[31m-    except Exception as e:[m
[31m-        print(f"Error generating commit message: {e}")[m
[31m-        return "chore: update files"[m
\ No newline at end of file[m
[1mdiff --git a/git_suggestion.py b/git_suggestion.py[m
[1mindex a42ccd2..3816725 100644[m
[1m--- a/git_suggestion.py[m
[1m+++ b/git_suggestion.py[m
[36m@@ -1,30 +1,27 @@[m
 from git import Repo[m
 [m
 def suggest_git_commands(repo):[m
[31m-    """[m
[31m-    Analyzes the repository state and suggests appropriate Git commands.[m
[31m-    Returns a list of suggested commands with explanations.[m
[31m-    """[m
[32m+[m[41m   [m
     suggestions = [][m
 [m
     try:[m
[31m-        # Check for untracked files[m
[32m+[m[32m        #Check for untracked files[m
         untracked_files = repo.untracked_files[m
         if untracked_files:[m
             suggestions.append({[m
                 "command": "git add .",[m
[31m-                "reason": f"Untracked files detected ({len(untracked_files)}). Add them to staging."[m
[32m+[m[32m                "reason": f"Number of Untracked files : {len(untracked_files)}. Add them to staging area."[m
             })[m
 [m
[31m-        # Check for staged changes[m
[32m+[m[32m        #Check for staged changes[m
         diff_staged = repo.git.diff("--staged")[m
         if diff_staged:[m
             suggestions.append({[m
                 "command": "git commit -m 'Your commit message'",[m
[31m-                "reason": "You have staged changes. Commit them to save your work."[m
[32m+[m[32m                "reason": "You have staged changes. Commit them in order to save your progress."[m
             })[m
 [m
[31m-        # Check for unstaged changes[m
[32m+[m[32m        #Check for unstaged changes[m
         diff_unstaged = repo.git.diff()[m
         if diff_unstaged and not diff_staged:[m
             suggestions.append({[m
[36m@@ -32,41 +29,46 @@[m [mdef suggest_git_commands(repo):[m
                 "reason": "You have unstaged changes. Stage them before committing."[m
             })[m
 [m
[31m-        # Check if the current branch is ahead of the remote[m
[32m+[m[32m        #Check if the current branch is ahead of or behind the remote[m
         current_branch = repo.active_branch.name[m
[31m-        remote_name = repo.active_branch.tracking_branch()[m
[31m-        if remote_name:[m
[31m-            remote_commit = repo.remotes[remote_name.remote_name].refs[remote_name.remote_head].commit[m
[32m+[m[32m        tracking_branch = repo.active_branch.tracking_branch()[m
[32m+[m
[32m+[m[32m        if tracking_branch:[m
[32m+[m[32m            remote_ref = repo.remotes[tracking_branch.remote_name].refs[tracking_branch.remote_head][m
[32m+[m[32m            remote_commit = remote_ref.commit[m
             local_commit = repo.head.commit[m
[31m-            if repo.git.rev_list(f"{remote_commit.hexsha}..{local_commit.hexsha}", count=True) != "0":[m
[32m+[m
[32m+[m[32m            #Check if local is ahead[m
[32m+[m[32m            ahead_count = repo.git.rev_list(f"{remote_commit}..HEAD", count=True)[m
[32m+[m[32m            if ahead_count != "0":[m
                 suggestions.append({[m
                     "command": f"git push origin {current_branch}",[m
                     "reason": f"Your branch '{current_branch}' is ahead of the remote. Push your changes."[m
                 })[m
 [m
[31m-        # Check if the remote is ahead of the local branch[m
[31m-        if remote_name:[m
[31m-            if repo.git.rev_list(f"{local_commit.hexsha}..{remote_commit.hexsha}", count=True) != "0":[m
[32m+[m[32m            #Check if remote is ahead[m
[32m+[m[32m            behind_count = repo.git.rev_list(f"HEAD..{remote_commit}", count=True)[m
[32m+[m[32m            if behind_count != "0":[m
                 suggestions.append({[m
                     "command": f"git pull origin {current_branch}",[m
[31m-                    "reason": f"Remote branch '{remote_name}' is ahead. Pull the latest changes."[m
[32m+[m[32m                    "reason": f"Remote branch '{tracking_branch}' is ahead. Pull the latest changes."[m
                 })[m
 [m
[31m-        # Check for multiple local branches (suggest merging or rebasing)[m
[32m+[m[32m        #Check for multiple local branches and suggest merging[m[41m [m
         if len(repo.branches) > 1 and current_branch != "main":[m
             suggestions.append({[m
                 "command": f"git checkout main && git merge {current_branch}",[m
[31m-                "reason": f"You are on branch '{current_branch}'. Merge it into 'main' when ready."[m
[32m+[m[32m                "reason": f"Current branch is '{current_branch}'. Merge it into 'master' branch when ready."[m
             })[m
 [m
[31m-        # If no suggestions, provide a default[m
[32m+[m[32m        #No suggestions, default case[m
         if not suggestions:[m
             suggestions.append({[m
                 "command": "git status",[m
[31m-                "reason": "No specific actions detected. Check the repository status for more details."[m
[32m+[m[32m                "reason": "No sugesstions. Check the repository status for more details."[m
             })[m
 [m
         return suggestions[m
 [m
     except Exception as e:[m
[31m-        return [{"command": "git status", "reason": f"Error analyzing repository state: {e}. Check the status manually."}][m
\ No newline at end of file[m
[32m+[m[32m        return [{"command": "git status", "reason": f"Error : {e}. Check status manually."}][m
\ No newline at end of file[m
[1mdiff --git a/main.py b/main.py[m
[1mindex def8b64..c1f3390 100644[m
[1m--- a/main.py[m
[1m+++ b/main.py[m
[36m@@ -1,45 +1,32 @@[m
 import sys[m
 from git import Repo[m
[31m-from commit_message import generate_commit_message[m
[31m-from git_suggestion import suggest_git_commands  # type: ignore[m
[32m+[m[32mfrom git_suggestion import suggest_git_commands # type: ignore[m
 [m
 def main():[m
[31m-    # Check if we're in a Git repository[m
[32m+[m
     try:[m
         repo = Repo(".")[m
         if repo.bare:[m
[31m-            print("Error: Not a Git repository.")[m
[32m+[m[32m            print("Not a Git repository.")[m
             sys.exit(1)[m
     except Exception as e:[m
         print(f"Error accessing Git repository: {e}")[m
         sys.exit(1)[m
 [m
[31m-    # Command-line interface[m
     if len(sys.argv) < 2:[m
[31m-        print("Usage: python main.py [commit_message|suggest] [diff]")[m
[32m+[m[32m        print("Use command: python main.py [suggest]")[m
         sys.exit(1)[m
 [m
     command = sys.argv[1][m
 [m
[31m-    if command == "commit_message":[m
[31m-        # Generate commit message based on staged changes[m
[31m-        diff = repo.git.diff("--staged")[m
[31m-        if not diff:[m
[31m-            print("No staged changes to commit.")[m
[31m-            sys.exit(1)[m
[31m-        message = generate_commit_message(repo, diff)[m
[31m-        print("Suggested commit message:")[m
[31m-        print(message)[m
[31m-[m
[31m-    elif command == "suggest":[m
[31m-        # Suggest Git commands based on repository state[m
[32m+[m[32m    if command == "suggest":[m
         suggestions = suggest_git_commands(repo)[m
         print("\nSuggested Git Commands:")[m
         for suggestion in suggestions:[m
             print(f"- {suggestion['command']}: {suggestion['reason']}")[m
 [m
     else:[m
[31m-        print("Unknown command. Use 'commit_message' or 'suggest'.")[m
[32m+[m[32m        print("Incorrect command. Use 'suggest'.")[m
         sys.exit(1)[m
 [m
 if __name__ == "__main__":[m
[1mdiff --git a/output.docx b/output.docx[m
[1mdeleted file mode 100644[m
[1mindex 825dac1..0000000[m
[1m--- a/output.docx[m
[1m+++ /dev/null[m
[36m@@ -1,4 +0,0 @@[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[1mdiff --git a/pr_review.py b/pr_review.py[m
[1mdeleted file mode 100644[m
[1mindex 16ee7be..0000000[m
[1m--- a/pr_review.py[m
[1m+++ /dev/null[m
[36m@@ -1,55 +0,0 @@[m
[31m-from transformers import pipeline[m
[31m-[m
[31m-def review_pr(repo, branch_name):[m
[31m-    try:[m
[31m-        # Ensure the branch exists[m
[31m-        if branch_name not in repo.heads:[m
[31m-            print(f"Error: Branch '{branch_name}' does not exist.")[m
[31m-            return[m
[31m-[m
[31m-        # Get the diff between the branch and main[m
[31m-        main_commit = repo.heads.main.commit[m
[31m-        branch_commit = repo.heads[branch_name].commit[m
[31m-        diff = branch_commit.diff(main_commit)[m
[31m-[m
[31m-        if not diff:[m
[31m-            print("No changes to review.")[m
[31m-            return[m
[31m-[m
[31m-        # Initialize AI model for text classification (sentiment analysis as a proxy for code quality)[m
[31m-        classifier = pipeline("sentiment-analysis", model="distilbert-base-uncased")[m
[31m-[m
[31m-        print(f"\nReviewing changes in branch '{branch_name}':")[m
[31m-        for change in diff:[m
[31m-            file_path = change.a_path or change.b_path[m
[31m-            print(f"\nFile: {file_path}")[m
[31m-[m
[31m-            # Extract the diff content[m
[31m-            if change.change_type == "D":[m
[31m-                print("File deleted. No review needed.")[m
[31m-                continue[m
[31m-            elif change.change_type == "A":[m
[31m-                content = change.b_blob.data_stream.read().decode("utf-8", errors="ignore")[m
[31m-            else:[m
[31m-                # For modified files, analyze the diff[m
[31m-                content = repo.git.diff(main_commit, branch_commit, file_path)[m
[31m-[m
[31m-            if not content.strip():[m
[31m-                print("No content to review.")[m
[31m-                continue[m
[31m-[m
[31m-            # Analyze the code changes with AI[m
[31m-            # For simplicity, we're using sentiment analysis on the diff content[m
[31m-            # In a real project, you'd fine-tune a model for code quality analysis[m
[31m-            result = classifier(content[:512])[0]  # Limit to 512 characters for the model[m
[31m-            label = result["label"][m
[31m-            score = result["score"][m
[31m-[m
[31m-            if label == "NEGATIVE" and score > 0.7:[m
[31m-                print("Potential issue detected in this file (confidence: {:.2f}%).".format(score * 100))[m
[31m-                print("Suggestion: Review this file for possible bugs or style violations.")[m
[31m-            else:[m
[31m-                print("Changes look good (confidence: {:.2f}%).".format(score * 100))[m
[31m-[m
[31m-    except Exception as e:[m
[31m-        print(f"Error during PR review: {e}")[m
\ No newline at end of file[m
